---
title: "Map states onto trees"
author: "Dan Benesh"
date: "February 25, 2019"
output: html_document
---

```{r setup, include=FALSE}
library(ggplot2)
library(dplyr)
library(tidyr)
library(ape)
library(RColorBrewer)
knitr::opts_chunk$set(echo = FALSE, warning = FALSE, message = FALSE)
options(stringsAsFactors = FALSE)
theme_set(new = theme_bw())
```

```{r get tree}
tree <- read.nexus(file = "ungulate_helminth_tree.nex")
tree$edge.length <- NULL # remove branch lengths
```

```{r get data}
tre_dat <- read.csv(file = "ungulate_helminth_tree_table.csv")
```

Probably need to fix some stuff, like internal organization of platyhelminths.
```{r}
plot(tree, cex = 0.5, show.tip.label = F, show.node.label = T)
```


```{r}
# reduce to just that in tree
tre_dat <- filter(tre_dat, in_tree)

# which OTL names not in tree
uniq_otl_names <- unique(tre_dat$otl_name)
tree$tip.label[!(tree$tip.label %in% uniq_otl_names)] # hopefully none after fixing last group

```

There are more rows in data than tip labels. This is because some families were synonomized, resulting in several rows in the data with the same otl name.

```{r}
group_by(tre_dat, otl_name)%>%
  summarize(n = n())%>%
  filter(n>1)
```

Go through and just take first one for those with multiple OTL entries for a given OTL name.

```{r}
rm(tre_dat_red)
for(otl in uniq_otl_names){
  # if otl just
  dx <- filter(tre_dat, otl_name == otl)
  if(dim(dx)[1] > 1) {
    # if more than one entry for otl name, just take first
    print
    dx <- dx[1,]
  }
  
  if(exists('tre_dat_red')) {
    tre_dat_red <- rbind(tre_dat_red, dx)
  } else {
    tre_dat_red <- dx
  }
}
rm(otl, dx)
```

```{r}
# put data in same order as tree tip labels
mv <- match(tree$tip.label, tre_dat_red$otl_name)
tre_dat_red <- tre_dat_red[mv,]
rm(mv)
```

```{r}
library(castor)
```


Mapping! First ungulate vs non-ungulate.

```{r}
# PARSIMONY
states_int <- map_to_state_space(tre_dat_red$ung_inf)
ac1 <- asr_max_parsimony(tree, states_int$mapped_states, Nstates = 2)
```

PLOT

```{r message=FALSE, warning=FALSE}
library(ggtree)
```

```{r}
# palette for two states
mypalette <- brewer.pal(n = states_int$Nstates, "Set1")[1:2]
```


```{r}
tree_df <- fortify(tree) # make a df
```


```{r}
# ancestral state reconstructions to add to tree
# if states given same probability take 1st one (not ungulate parasite)
node_states <- apply(ac1$ancestral_likelihoods, 1, function(x) which(x == max(x))[1])
node_states <- unlist(node_states)

# combine tip and branch states, add them to tree df (correct order)
state <- c(states_int$mapped_states, node_states)
tree_df$state <- state
tree_df <- mutate(tree_df, 
                  state = if_else(state == 1, "not ungulate parasite", "ungulate parasite"))


# plot tree
p <- ggtree(tree_df) + 
  geom_tree(aes(color = state)) + 
  geom_tiplab(data = filter(tree_df, state == 'ungulate parasite'),
              size = 1.5, color = mypalette[2]) +
  xlim(0, max(tree_df$x) + 0.09) +
  theme(legend.position = c(0.5, 1), 
        legend.justification = c(1,1),
        legend.title = element_blank(),
        legend.text = element_text(size = 14))

p
```

```{r}
# # plot tree with all tip labels
# p <- ggtree(tree_df) + 
#   geom_tree(aes(color = state)) + 
#   geom_tiplab(aes(color = state), size = 2) +
#   xlim(0, max(tree_df$x) + 0.09) +
#   scale_color_manual(values = mypalette) +
#   theme(legend.position = c(0.5, 1), 
#         legend.justification = c(1,1),
#         legend.title = element_blank(),
#         legend.text = element_text(size = 14))
```

```{r}
# plot with node labels
# p + geom_text2(aes(subset=!isTip, label=node), hjust=-.3)
```

Find the nodes with the transitions

```{r}
# reduce to just tree structure and states
trans_states <- select(tree_df, child_node = node, parent_node = parent, child_state = state)
# self join to get states for both parent and child side by side
trans_states <- left_join(trans_states, 
                           select(trans_states, child_node, parent_state = child_state),
                           by = c("parent_node" = "child_node") ) 
# only cases where parent and child have different states
trans_states <- filter(trans_statesx, child_state != parent_state)%>%
  filter(child_state == "ungulate parasite")
#filter(tree_df, node %in% trans_statesx$child_node) # check if transitions correctly identified - looks good

# add transitions to plotting df
tree_df <- mutate(tree_df, trans_node = if_else(node %in% trans_states$parent_node, TRUE, FALSE))

# add points onto plot
p <- p +
  geom_nodepoint(data = filter(tree_df, trans_node), 
                 shape = 19, size = 3, color = mypalette[2], alpha = 0.75) 

p
```


```{r}
ggsave(filename = 'test.pdf', width = 297, height = 210, units = "mm")
```



Now map the transmission strategies!
